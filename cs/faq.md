# 1. 클래스 / 객체 / 인스턴스의 차이

## 1. 클래스

* 객체(object)를 만들어내기 위한 **틀**이며 만들어낼 객체의 속성과 매서드의 집합을 담아놓은 것

## 2. 객체

* 클래스로부터 만들어지는 실체, 클래스로 **선언**된 변수를 객체라 한다

## 3. 인스턴스

* 객체가 **메모리에 할당**이 된 상태이며 런타임에 구동되는 객체. 객체와 같은 의미로 쓰이기도 함

# 2. static 키워드는 왜 사용하며 단점은 무엇인가?

* 클래스의 인스턴스가 아닌 **클래스에 속하며 클래스의 변수, 메서드 등을 공유**하는데 사용
* 이를 통해 해당 클래스로 만들어지는 객체 사이에서 **중복되는 메서드, 속성을 효율적으로 정의**할 때 쓰이며 단순히 전역변수가 아니라 클래스 내의 static 키워드로 선언하여 **이 클래스의 객체들끼리 사용
  **되는 메서드
  또는 속성이라는 것을 나타내주는 **명시성**이라는 장점이 생기기 때문에 사용
* 선언과 동시에 heap영역이 아닌 method 영역에 할당되며 프로그램이 종료될 때까지 GC에 의해 메모리가 회수되지 않기 대문에 만약 클래스가 객체르 쓰이지 않는다면 메모리 낭비를 불러올 수 있음

# 3. 오버로딩과 오버라이딩은 무엇인가?

## 오버로딩(Overloading)

* 이름이 같아도 매개변수 개수, 타입, 순서를 다르게 해서 **같은 이름으로도 여러 개의 함수를 정의**할 수 있는 것
* 프로그램의 유연성을 높이고 코드를 깔끔하게 하는 효과가 있으며 같은 클래스 내에서 사용

## 오버라이딩(Overriding)

* 상위 클래스가 가지고 있는 메서드를 **하위 클래스가 재정의** 하는 것
* 상속 관계 클래스에서 사용되며 static, final 로 선언한 메서드는 오버라이딩이 불가능

# 4. 추상화란 무엇인가?

* 복잡한 데이터, 구조, 시스템 등으로부터 핵심만을 가려내 덜 자세하게 만드는 것 또는 세부사항, 절차 등을 감추고 인터페이스 등을 만드는 것으로 복잡도를 낮추는 방법

## 데이터 추상화

* 데이터들의 공통점을 모으고 차이점은 버린다.
* 카테고리화

## 프로세스 추상화

* 내부 프로세스를 숨긴다.
* ex) 데이터베이스가 어떻게 데이터를 저장하는지는 모르지만 단순히 insert, update 등의 쿼리로 데이터를 저장할 수 있음

# 5. 컴파일러 언어와 인터프리터 언어의 차이가 무엇인가?

* 프로그래밍 언어로 작성된 코드를 컴퓨터가 이해할 수 있는 기계어로 변환하는 과정에 관여하는 프로그램

## 컴파일러

* 전체 변환: 소스 코드의 전체를 읽어 한 번에 기계어로 변환
* 변환 과정을 거친 후, 생성된 기계어 코드를 실행
* 속도: 컴파일 과정 자체는 시간이 걸리지만, 변환된 코드는 직접 실행되므로 실행 시간은 빠름
* 사용 예: C, C++, Go, Rust 등의 언어가 컴파일러를 사용
* 코드를 수정했을 때 컴파일 과정이 필요

## 인터프리터

* 한 줄씩 변환: 소스 코드를 한 줄씩 읽어가며 바로 기계어로 변환하고 실행
* 속도: 컴파일 단계가 없으므로 초기 시작은 빠르지만, 전체 코드 실행 시간은 컴파일러를 사용할 때보다 느릴 수 있음
    * 코드를 실행할 때마다 변환 과정을 거치기 때문
* 사용 예: Python이 대표적으로 인터프리터 방식을 사용
* 코드를 수정했을 때 컴파일 과정이 필요하지 않음

## 모두 고수준의 언어를 기계어로 변환한다는 공통점

## JIT 컴파일러

* 인터프리터와 컴파일러의 중간 형태
* **코드 분석**: 실행 시점에 프로그램 코드를 분석하여, 어떤 부분이 가장 자주 실행되는지(hot spot) 판단.(즉, 실행전 코드를 분석하지 않음)
* **동적 컴파일**: 분석 결과에 기반하여, 자주 실행되는 코드(hot spot)만을 선별적으로 기계어로 변환. 이 과정은 프로그램 실행 중에 실시간으로 이루어짐
* **최적화**: 컴파일 과정에서 다양한 최적화 기법을 적용. (ex. 메모리 접근 패턴을 분석, 가비지 컬렉션의 오버헤드 최소화 등)
* **실행**: 컴파일된 기계어 코드를 실행. 프로그램이 계속 실행되면서 새로운 핫스팟이 발견되면, 해당 부분도 JIT 컴파일을 통해 최적화