# 정적 배열(Array)

* 선언할 때 보통 크기를 설정해서 연산을 진행
* 연속된 메모리 공간에 위치한 같은 타입의 요소들의 모음
* 숫자 인덱스를 기반으로 랜덤 접근이 가능하며 중복을 허용

# 동적 배열(Vector)

* 동적으로 요소를 할당할 수 있는 배열
* 만약 컴파일 시점에 사용해야 할 요소들의 개수를 모른다면 Vector를 써야 함
* 연속된 메모리 공간에 위치하 ㄴ같으 ㄴ타입의 요소들의 모음
* 숫자 인덱스를 기반으로 랜덤 접근이 가능하며 중복을 허용

## 시간 복잡도

* 참조: O(1)
* 탐색: O(n)
* 맨 끝에 삽입/삭제: O(1)
* 맨 끝 제외 삽입/삭제: O(n)

# 연결 리스트(Linked List)

* 노드로 감싸진 요소를 인접한 메모리 위치가 아닌 독립적으로 저장하며 각 노드는 next 또는 next, prev 라는 포인터로 서로 연결된 선형적인 자료 구조

## 시간 복잡도

* 참조: O(n)
* 탐색: O(n)
* 삽입/삭제: O(1)

## 싱글 연결리스트

* Singly Linked List 는 next 포인터밖에 존재하지 않으며 한 방향으로만 데이터가 연결됨

## 이중 연결리스트

* Doubly Linked List 는 prev, next 두 개의 포인터로 양방향으로 데이터가 연결됨

## 원형 연결리스트

* Circular Linked List 는 마지막 노드와 첫 번째 노드가 연결되어 원을 형성
* 싱글 연결리스트 똔느 이중 연결리스트로 이루어진 2가지 타입의 원형 연결리스트가 있음

## 랜덤 접근과 순차적 접근

* 직접 접근이라고 하는 랜덤 접근(Random access) 은 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
* 데이터를 저장된 순서대로 검색해야 하는 순처적 접근(Sequential access)과 반대
* 배열은 랜덤 접근이 가능해서 n번째 요소에 접근할 때 O(1) 소요
* 연결리스트, 스택, 큐는 순차적 접근만 가능해서 n번째 요소에 접근할 때 O(n) 소요

# 스택(Stack)

* 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질인 후입선출(LIFO, Last In First Out)을 가진 자료 구조
* 재귀적인 함수, 알고리즘에 사용되며 웹 브라우저 방문 기록 등에 사용

## 시간 복잡도

* n번째 참조: O(n)
* 가장 앞부분 참조: O(1)
* 탐색: O(n)
* 삽입/삭제(n번째 제외): O(n)

# 큐(Queue)

* 먼저 집어넣은 데이터가 먼저 나오는 성질인 선입선출(FIFO, First In First Out)을 지닌 자료 구조
* 나중에 집어넣은 데이터가 먼저 나오는 스택과는 반대되는 개념
* CPU 작업을 기다리는 프로ㅔㅅ스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비우선 탐색, 캐시 등에 사용

## 시간 복잡도

* n번째 참조: O(n)
* 가장 앞부분 참조: O(1)
* 탐색: O(n)
* 삽입/삭제(n번째 제외): O(1)