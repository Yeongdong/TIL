# 목차

1. [맵(Map)](#map)
    - [시간복잡도](#map-시간복잡도)
2. [셋(Set)](#set)
    - [시간복잡도](#set-시간복잡도)
3. [해시 테이블(Hash Table)](#hash-table)
    - [해시, 해싱, 해시함수](#해시-해싱-해시함수)
    - [시간복잡도](#hash-table-시간복잡도)
        - [평균 시간복잡도](#평균-시간복잡도)
        - [최악의 시간복잡도](#최악의-시간복잡도)
    - [해시테이블의 충돌문제 해결](#해시테이블의-충돌문제-해결)
        - [체이닝](#체이닝)
        - [개방 주소법(Open Addressing)](#개방-주소법open-addressing)
            - [선형 탐색(Linear Probing)](#선형-탐색linear-probing)
            - [제곱 탐색(Quadratic Probing)](#제곱-탐색quadratic-probing)
            - [이중 해싱(Double Hashing)](#이중-해싱double-hashing)
4. [힙(Heap)](#힙)
    - [힙의 데이터 삽입](#힙의-데이터-삽입)
    - [힙의 데이터 삭제](#힙의-데이터-삭제)
    - [이진 탐색 트리와의 차이점](#이진-탐색-트리와의-차이점)
    - [시간 복잡도](#힙-시간-복잡도)

# 맵(Map)

* 고유한 키를 기반으로 키-값(key-value) 쌍으로 이루어져 있는 정렬된(삽입할 때마다 자동 정렬되는) 자료구조
* 균형잡힌 이진탐색트리인 레드 - 블랙 트리로 구현됨
* 고유한 키를 갖기 때문에 하나의 키에 중복된 갑싱 들어갈 수 없음
* 자동으로 오름차순 정렬되기 때문에 넣은 순서대로 map을 탐색할 수 있는 것이 아닌 ASCII 코드순으로 정렬된 값들을 기반으로 탐색

## 시간복잡도

* 참조: O(logN)
* 탐색: O(logN)
* 삽입/삭제: O(logN)

# 셋(Set)

* 고유한 요소만을 저장하는 자료구조
    * 중복을 허용하지 않음
* 중복된 값은 제거되며 map과 같이 자동 정렬됨

## 시간복잡도

* 참조: O(logN)
* 탐색: O(logN)
* 삽입/삭제: O(logN)

# 해시 테이블(Hash Table)

* 큰 범위를 가진 각양각색의 데이터들을 해싱을 통해 한정된 범위의 정수값을 가진 해시로 만들고 해시라는 키에 대응하여 원본 데이터들을 매핑시켜놓은 테이블

## 해시, 해싱, 해시함수

* 해시
    * 다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑한 값
* 해싱
    * 임의의 데이터를 해시로 바꿔주는 일이며 해시 함수가 이를 담당
* 해시 함수
    * 임의의 데이터를 입력으로 받아 일정한 길이의 데이터로 바꿔주는 함수

## 시간복잡도

### 평균시간복잡도

* 해시테이블은 최악의 시간복잡도와 평균 시간복잡도의 차이가 크며 이를 고려해서 쓸지 말지를 고민해야 함
* 해당 키를 기반으로 배여렝서 인덱스로 접근하듯이 접근할 수 있어 평균적으로 O(1)의 시간복잡도를 가짐
    * 참조: O(1)
    * 탐색: O(1)
    * 삽입/삭제: O(1)

### 최악의 시간복잡도

* 해시테이블에서 충돌이 많이 일어난다면 해당 해시값이 같은 모든 요소들을 탐색해야 하므로 O(n)의 시간복잡도가 걸림
    * 참조: O(n)
    * 탐색: O(n)
    * 삽입/삭제: O(n)

## 해시테이블의 충돌문제 해결

* 해시테이블에서 같은 해시값이 나타나는 것을 볼 수 있었고, 이때문에 충돌문제(hash collision)가 발생
    * birthday paradox
        * 해시테이블의 충돌문제는 "거의 무조건" 발생
        * 아주 큰 테이블을 형성한다 해도 birthday paradox에 의해 충돌이 발생될 확률이 높음
        * 같은 방에 생일이 같은 사람이 두 명 있을 확률이 50%가 되려면 방에 23명 밖에 없어도 됨

### 체이닝

* 충돌시 연결리스트에 할당하고 충돌시 연결리스트를 탐색하는 기법
* 연결리스트 뿐만 아니라 동적 배열, 균형잡힌 트리인 레드블랙트리가 사용되며 Java 8 이상에서는 요소의 수가 특정 임계값을 초과하면 연결리스트가 아닌 레드블랙트리를 HashMap에서 사용함. 이를 통해 최악의
  시간복잡도를 O(n) -> O(logN)으로 개선
    * 장점
        * 구현이 간단하며 해시테이블에 많은 데이터를 집어넣을 수 있음
    * 단점
        * 연결리스트 기반이라 캐시 성능이 좋지 않음
        * 체인이 길어지면 최악의 경우 O(n)이 될 수 있음

### 개방 주소법(Open Addressing)

* 충돌시 다른 버켓에 데이터를 삽입하는 기법
* 선형 탐색, 제곱 탐색, 이중 해시 방법이 있음

#### 선형 탐색(Linear Probing)

* 해시충돌시 다음 버켓, 혹은 몇 개를 "선형적으로" 건너뛰어 데이터를 삽입

#### 제곱 탐색(Quadratic Probing)

* 해시충돌시 1부터 연속적인 수를 만들며 해당 수의 제곱만큼 건너뛴 버켓에 데이터를 삽입하는 것

#### 이중 해싱(Double Hashing)

* 해시충돌시 다른 해시함수를 한 번 더 적용한 결과를 이용해 데이터를 삽입

# 힙

* 여러 개의 값 중에서 가장 크거나 작은 값을 빠르게 찾기 위해 만든 완전 이진 트리
* 가장 작은 요소가 루트노드에 있는 최소 힙
    * 부모 노드의 값은 자식 노드의 값보다 항상 작은 규칙을 지키는 힙
    * 요소 중 가장 작은 값을 O(1)만에 찾을 수 있음
* 가장 큰 요소가 루트노드에 있는 최대 힙
    * 부모 노드의 값은 자식 노드의 값보다 항상 큰 규칙을 지키는 힙
    * 요소 중 가장 큰 값을 O(1)만에 찾을 수 있음

## 힙의 데이터 삽입

1. 리프노드에 삽입할 노드를 삽입
2. 해당 노드와 부모 노드를 서로 비교
3. "규칙"에 맞으면 그대로 두고, 그렇지 않으면 부모 노드와 교환
4. 규치겡 맞을 때까지 3번 과정을 반복

## 힙의 데이터 삭제

* 루트 노드만을 제거할 수 있음

1. 루트 노드 제거
2. 루트자리에 가장 마지막 노드(리프 노드)를 삽입
3. 올라간 노드와 그의 자식 노드와 비교
4. 규칙을 만족하면 그대로 두고, 그렇지 않으면 자식 노드와 교환

## 이진 탐색 트리와의 차이점

* 이진 탐색트리는 탐색을 쉽게 하기 위해 왼쪽이ㅐ 더 작고 오른쪽이 큰 값으로 꼭 구성이 되어야 하지만 힙은 그렇지 않음
* 최소 힙을 기반으로 설명하면 이진탐색트리는 왼쪽 자식노드가 부모노드보다 더 작은 값을 가지는데 최소 힙은 그렇지 않음

## 시간 복잡도

* 참조(최대 또는 최소값을 참조): O(1)
* 탐색: O(n)
* 삽입/삭제: O(logN)