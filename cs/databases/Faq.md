# 목차

1. [정규화 과정은 꼭 필요할까?](#정규화-과정은-꼭-필요할까)
    - [정규화 과정](#정규화-과정)
    - [정규화 과정이 필요한 이유](#정규화-과정이-필요한-이유)

2. [관계형 데이터베이스와 NoSQL 데이터베이스의 차이](#관계형-데이터베이스와-nosql-데이터베이스의-차이)

3. [MySQL의 innoDB, MyISAM 스토리지엔진의 차이](#mysql의-innodb-myisam-스토리지엔진의-차이)

4. [데이터베이스의 데드록과 해결방법](#데이터베이스의-데드록과-해결방법)
    - [데드락](#데드락)
    - [해결방법: 데드락 탐지](#해결방법-데드락-탐지)
        - [1. timeout](#1-timeout)
        - [2. wait for graph](#2-wait-for-graph)
    - [해결방법: 데드락 방지](#해결방법-데드락-방지)
        - [1. 격리 수준 변경](#1-격리-수준-변경)
        - [2. 자원 할당 순서 지정](#2-자원-할당-순서-지정ordering-of-resource-allocation)
        - [3. wait-die 방법](#3-wait-die-방법)
        - [4. wound-wait](#4-wound-wait)

# 정규화 과정은 꼭 필요할까?

## 정규화 과정

1. 비정규형 릴레이션
2. 제 1정규형: 모든 속성이 원자값
3. 제 2정규형: 모든 속성, 기본키에 완전함수종속
4. 제 3정규형: 키본키에 이행적 함수종속X
5. 보이스 / 코드 정규형: 모든 결정자가 후보키

## 정규화 과정이 필요한 이유

* 테이블을 나누게 되면 성능이 좋아질 수도, 나빠질 수도 있음
* 예를 들어, 어떠한 쿼리는 테이블을 나눠버린 경우 "조인"을 계속해야 하기 때문에 오히려 느려질 수 있음
* 따라서 서비스에 따라 정규화 똔느 비정규화 과정을 진행해야 함
* 정규화 과정은 중복 데이터가 제거됨에 따라 스토리지에 대한 전체 메모리 요구량이 감소하게 됨
* 또한 테이블이 더 정상적이게 되므로 오류가 발생할 가능성이 줄어듬
* 하지만 조인이 많이 필요한 쿼리가 많아진다면 어느 정도 비정규화가 필요함

# 관계형 데이터베이스와 NoSQL 데이터베이스의 차이

| 기능/특징   | RDBMS                      | NoSQL 데이터베이스                                         |
|---------|----------------------------|------------------------------------------------------|
| 스키마     | 엄격하고 정의되어야 함               | 유연하고 동적으로 변경 가능                                      |
| 쿼리 언어   | SQL                        | JSON, API, Cypher(Neo4j) 등 다양함<br>https://neo4j.com/ |
| 트랜잭션    | 지원                         | 지원                                                   |
| 격리성(기본) | repeatable_read(mysql)     | local := read_uncommited<br>(mongodb)                |
| 스케일링    | 수직 스케일링이 더 쉬움<br>- 서버 성능향상 | 수평 스케일링이 더 쉬움<br>- 서버 대수 증가                          |
| 예       | MySQL, Oracle, PostgreSQL  | MongoDB, Redis, ElasticSearch,<br>Neo4j              |

# MySQL의 innoDB, MyISAM 스토리지엔진의 차이

* 데이터베이스의 스토리지 엔진은 데이터베이스 시스템에서 데이터의 저장, 검색, 트랜잭션 관리, 동시성 제어, 캐싱 등 핵심을 담당하는 필수 구성 요소
* InnoDB는 MySQL 8.0의 기본 스토리지 엔진
* MyISAM이라는 스토리지엔진으로도 변경 가능
* 차이점

| 특성      | InnoDB | MyISAM   |
  |---------|--------|----------|
| 트랜잭션 지원 | 지원     | 미지원      |
| 락 및 동시성 | 행 레벨 락 | 테이블 레벨 락 |
| 외래 키 제약 | 지원     | 미지원      |

# 데이터베이스의 데드록과 해결방법

## 데드락

* 둘 이상의 트랜잭션이 서로가 잠금을 포기하기를 기다리는 상황(교착상태)
* 다음 조건들이 동시에 충족될 때 발동
    * **상호 배재(Mutual Exclusion)**
        * 자원은 한 번에 하나의 트랜잭션만 사용할 수 있음
    * **점유 및 대기(Hold and Wait)**
        * 트랜잭션이 최소한 하나의 자원을 점유하고 잇으면서 다른 트랜잭션이 점유한 자원을 추가로 요구할 때 발생
    * **비선점(No Preemption)**
        * 한 트랜잭션이 점유한 자원은 그 트랜잭션이 명시적으로 해제할 때까지 다른 트랜잭션에 의해 강제로 빼앗길 수 없음
    * **순환 대기(Circular Wait)**
        * 각 트랜잭션이 순환적으로 당므 트랜잭션에 의해 점유된 자원을 대기하는 상태

## 해결방법: 데드락 탐지

### 1. timeout

* 일정시간(timeout) 이후 트랜잭션이 실행되지 않았을 때 롤백
* 직접적으로 탐지하는 것은 아니지만 일정 시간 이후 트랜잭션이 실행되지 않음을 교착상태로 정의해서 탐지
* 장점
    * 구현이 간단하고 데드락 상황을 빠르게 해결할 수 있음
* 단점
    * 타임아웃 설정이 어려움
    * 너무 짧으면 불필요한 중단이 발생할 수 있고, 너무 길면 데드락을 해결하는데 시간이 오래 걸림
    * 실제 데드락이 아닌 상황에서도 트랜잭션이 중단될 수 있음

### 2. wait for graph

* 트랜잭션에 관한 대기 그래프를 만들고 해당 그래프에 사이클이 발생됨을 주기적으로 검사
* 대규모 데이터베이스의 경우 모든 트랜잭션의 사이클을 찾아 데드락을 감지하는 것은 코스트가 큼
* 보통 timeout과 데드락 방지 방법을 사용

## 해결방법: 데드락 방지

* 애초에 최대한 데드락이 일어나지 않게 방지하는 것

### 1. 격리 수준 변경

* 데드락을 방지하기 위해 격리 수준을 조정하는 것
    * ex) REPEATABLE_READ -> SERIALIZABLE
* 다만 serializable이 아닌 이상 모든 데드락을 제거할 수는 없음

### 2. 자원 할당 순서 지정(Ordering of Resource Allocation)

* 서비스 로직을 구축할 때 자원 할당이 교착 상태가 발생하지 않도록 서비스의 논리 구조를 바꾸는 것
* 필요 자원이 서로 교차되지 않고 일관성있게 바꿈

### 3. wait-die 방법

* 타임스탬프를 기반으로 오래된 트랜잭션을 좀 더 우선순위가 높다고 판정하여 이에 따라 대기, 강제 종료 등을 하는 방식을 가진 **비선점 기법**

#### 작동 방식

* 기다림(Wait)
    * 우선순위가 높은 트랜잭션이 자원을 요청했을 때, 그 자원이 이미 우선순위가 낮은 트랜잭션에 의해 점유되어 있으면, 우선순위가 높은 트랜잭션은 대기 상태로 들어감
* 죽음(Die)
    * 반대로 우선순위가 낮은 트랜잭션이 자원을 요청했을 때, 그 자원이 이미 우선순위가 높은 트랜잭션에 의해 점유되어 있으면, 우선순위가 낮은 트랜잭션은 롤백(취소)되고, 나중에 다시 시도

#### 작동 예제

* T5: Old Transaction(타임스탬프 5)
* T10: Young Transaction(타임스탬프 10)
* wait: T5가 T10이 점유한 자원을 요청하면 T5는 대기
* die: T10이 T5가 점유한 자원을 요청하면 T10은 롤백. 재시도. => 시도를 강제로 죽임

### 4. wound-wait

* 타임스탬프를 기반으로 오래된 트랜잭션을 좀 더 우선순위가 높다고 판정하여 이에 따라 대기, 강제 종료 등을 하는 방식을 가진 **선점 기법**

#### 작동 방식

* 부상(Wound)
    * 우선순위가 높은 트랜잭션이 자원을 요청했을 때, 그 자원이 이미 우선순위가 낮은 트랜잭션에 의해 점유되어 있으면, 우선순위가 낮은 트랜잭션을 "부상"시킴
    * 해당 트랜잭션의 점유자원을 강제 해제하고 우선순위가 높은 트랜잭션에게 넘겨줌
* 대기(Wait)
    * 반대로 우선순위가 낮은 트랜잭션이 자원을 요청했을 때 그 자원이 이미 우선순위가 높은 트랜잭션에 의해 점유되어 있으면, 우선순위가 낮은 트랜잭션은 높은 우선순위를 가진 트랜잭션이 해제될 때까지 기다림

#### 작동 예제

* T5: Old Transaction(타임스탬프 5)
* T10: Young Transaction(타임스탬프 10)
* wound: T5가 T10이 점유한 자원을 요청하면 T5는 죽음
* wait: T10이 T5가 점유한 자원을 요청하면 T10은 T5가 끝날 때까지 대기

* 애다운애(wait-die-wound-wait)